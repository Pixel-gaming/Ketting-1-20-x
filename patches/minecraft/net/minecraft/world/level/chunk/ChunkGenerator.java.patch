--- a/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -77,7 +_,7 @@
 
 public abstract class ChunkGenerator {
    public static final Codec<ChunkGenerator> CODEC = BuiltInRegistries.CHUNK_GENERATOR.byNameCodec().dispatchStable(ChunkGenerator::codec, Function.identity());
-   public BiomeSource biomeSource;
+   protected BiomeSource biomeSource; //Ketting - not final
    private final Supplier<List<FeatureSorter.StepFeatureData>> featuresPerStep;
    public final Function<Holder<Biome>, BiomeGenerationSettings> generationSettingsGetter;
 
@@ -97,10 +_,16 @@
       });
    }
 
+   //Ketting start - make biomeSource configurable
+   public void setBiomeSource(BiomeSource biomeSource) {
+       this.biomeSource = biomeSource;
+   }
+   //Ketting end
+
    protected abstract Codec<? extends ChunkGenerator> codec();
 
-   public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> p_256405_, RandomState p_256101_, long p_256018_) {
-      return ChunkGeneratorStructureState.createForNormal(p_256101_, p_256018_, this.biomeSource, p_256405_);
+   public ChunkGeneratorStructureState createState(HolderLookup<StructureSet> p_256405_, RandomState p_256101_, long p_256018_, org.spigotmc.SpigotWorldConfig conf) { // Spigot
+      return ChunkGeneratorStructureState.createForNormal(p_256101_, p_256018_, this.biomeSource, p_256405_, conf);
    }
 
    public Optional<ResourceKey<Codec<? extends ChunkGenerator>>> getTypeNameForDataFixer() {
@@ -264,106 +_,142 @@
          return false;
       }
    }
+   
+   public void addVanillaDecorations(WorldGenLevel p_223087_, ChunkAccess p_223088_, StructureManager p_223089_) { // CraftBukkit
+      // Ketting - Handle this method in the original place
+      ketting$onlyAddVanillaDecoration.set(true);
+      applyBiomeDecoration(p_223087_, p_223088_, p_223089_, true);
+      // Ketting end
+   }
 
+   // CraftBukkit start
+   public java.util.concurrent.atomic.AtomicBoolean ketting$vanilla = new java.util.concurrent.atomic.AtomicBoolean(true); // Ketting
+   public java.util.concurrent.atomic.AtomicBoolean ketting$onlyAddVanillaDecoration = new java.util.concurrent.atomic.AtomicBoolean(false); // Ketting
    public void applyBiomeDecoration(WorldGenLevel p_223087_, ChunkAccess p_223088_, StructureManager p_223089_) {
-      ChunkPos chunkpos = p_223088_.getPos();
-      if (!SharedConstants.debugVoidTerrain(chunkpos)) {
-         SectionPos sectionpos = SectionPos.of(chunkpos, p_223087_.getMinSection());
-         BlockPos blockpos = sectionpos.origin();
-         Registry<Structure> registry = p_223087_.registryAccess().registryOrThrow(Registries.STRUCTURE);
-         Map<Integer, List<Structure>> map = registry.stream().collect(Collectors.groupingBy((p_223103_) -> {
-            return p_223103_.step().ordinal();
-         }));
-         List<FeatureSorter.StepFeatureData> list = this.featuresPerStep.get();
-         WorldgenRandom worldgenrandom = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.generateUniqueSeed()));
-         long i = worldgenrandom.setDecorationSeed(p_223087_.getSeed(), blockpos.getX(), blockpos.getZ());
-         Set<Holder<Biome>> set = new ObjectArraySet<>();
-         ChunkPos.rangeClosed(sectionpos.chunk(), 1).forEach((p_223093_) -> {
-            ChunkAccess chunkaccess = p_223087_.getChunk(p_223093_.x, p_223093_.z);
-
-            for(LevelChunkSection levelchunksection : chunkaccess.getSections()) {
-               levelchunksection.getBiomes().getAll(set::add);
-            }
-
-         });
-         set.retainAll(this.biomeSource.possibleBiomes());
-         int j = list.size();
-
-         try {
-            Registry<PlacedFeature> registry1 = p_223087_.registryAccess().registryOrThrow(Registries.PLACED_FEATURE);
-            int i1 = Math.max(GenerationStep.Decoration.values().length, j);
-
-            for(int k = 0; k < i1; ++k) {
-               int l = 0;
-               if (p_223089_.shouldGenerateStructures()) {
-                  for(Structure structure : map.getOrDefault(k, Collections.emptyList())) {
-                     worldgenrandom.setFeatureSeed(i, l, k);
-                     Supplier<String> supplier = () -> {
-                        return registry.getResourceKey(structure).map(Object::toString).orElseGet(structure::toString);
-                     };
-
-                     try {
-                        p_223087_.setCurrentlyGenerating(supplier);
-                        p_223089_.startsForStructure(sectionpos, structure).forEach((p_223086_) -> {
-                           p_223086_.placeInChunk(p_223087_, p_223089_, this, worldgenrandom, getWritableArea(p_223088_), chunkpos);
-                        });
-                     } catch (Exception exception) {
-                        CrashReport crashreport1 = CrashReport.forThrowable(exception, "Feature placement");
-                        crashreport1.addCategory("Feature").setDetail("Description", supplier::get);
-                        throw new ReportedException(crashreport1);
-                     }
-
-                     ++l;
-                  }
-               }
-
-               if (k < j) {
-                  IntSet intset = new IntArraySet();
-
-                  for(Holder<Biome> holder : set) {
-                     List<HolderSet<PlacedFeature>> list1 = this.generationSettingsGetter.apply(holder).features();
-                     if (k < list1.size()) {
-                        HolderSet<PlacedFeature> holderset = list1.get(k);
-                        FeatureSorter.StepFeatureData featuresorter$stepfeaturedata1 = list.get(k);
-                        holderset.stream().map(Holder::value).forEach((p_223174_) -> {
-                           intset.add(featuresorter$stepfeaturedata1.indexMapping().applyAsInt(p_223174_));
-                        });
-                     }
-                  }
-
-                  int j1 = intset.size();
-                  int[] aint = intset.toIntArray();
-                  Arrays.sort(aint);
-                  FeatureSorter.StepFeatureData featuresorter$stepfeaturedata = list.get(k);
-
-                  for(int k1 = 0; k1 < j1; ++k1) {
-                     int l1 = aint[k1];
-                     PlacedFeature placedfeature = featuresorter$stepfeaturedata.features().get(l1);
-                     Supplier<String> supplier1 = () -> {
-                        return registry1.getResourceKey(placedfeature).map(Object::toString).orElseGet(placedfeature::toString);
-                     };
-                     worldgenrandom.setFeatureSeed(i, l1, k);
-
-                     try {
-                        p_223087_.setCurrentlyGenerating(supplier1);
-                        placedfeature.placeWithBiomeCheck(p_223087_, this, worldgenrandom, blockpos);
-                     } catch (Exception exception1) {
-                        CrashReport crashreport2 = CrashReport.forThrowable(exception1, "Feature placement");
-                        crashreport2.addCategory("Feature").setDetail("Description", supplier1::get);
-                        throw new ReportedException(crashreport2);
-                     }
-                  }
-               }
-            }
-
-            p_223087_.setCurrentlyGenerating((Supplier<String>)null);
-         } catch (Exception exception2) {
-            CrashReport crashreport = CrashReport.forThrowable(exception2, "Biome decoration");
-            crashreport.addCategory("Generation").setDetail("CenterX", chunkpos.x).setDetail("CenterZ", chunkpos.z).setDetail("Seed", i);
-            throw new ReportedException(crashreport);
-         }
-      }
-   }
+      if (ketting$vanilla.getAndSet(true)) {
+         ChunkPos chunkpos = p_223088_.getPos();
+         if (!SharedConstants.debugVoidTerrain(chunkpos)) {
+            SectionPos sectionpos = SectionPos.of(chunkpos, p_223087_.getMinSection());
+            BlockPos blockpos = sectionpos.origin();
+            Registry<Structure> registry = p_223087_.registryAccess().registryOrThrow(Registries.STRUCTURE);
+            Map<Integer, List<Structure>> map = registry.stream().collect(Collectors.groupingBy((p_223103_) -> {
+               return p_223103_.step().ordinal();
+            }));
+            List<FeatureSorter.StepFeatureData> list = this.featuresPerStep.get();
+            WorldgenRandom worldgenrandom = new WorldgenRandom(new XoroshiroRandomSource(RandomSupport.generateUniqueSeed()));
+            long i = worldgenrandom.setDecorationSeed(p_223087_.getSeed(), blockpos.getX(), blockpos.getZ());
+            Set<Holder<Biome>> set = new ObjectArraySet<>();
+            ChunkPos.rangeClosed(sectionpos.chunk(), 1).forEach((p_223093_) -> {
+               ChunkAccess chunkaccess = p_223087_.getChunk(p_223093_.x, p_223093_.z);
+
+               for(LevelChunkSection levelchunksection : chunkaccess.getSections()) {
+                  levelchunksection.getBiomes().getAll(set::add);
+               }
+
+            });
+            set.retainAll(this.biomeSource.possibleBiomes());
+            int j = list.size();
+
+            try {
+               Registry<PlacedFeature> registry1 = p_223087_.registryAccess().registryOrThrow(Registries.PLACED_FEATURE);
+               int i1 = Math.max(GenerationStep.Decoration.values().length, j);
+
+               for(int k = 0; k < i1; ++k) {
+                  int l = 0;
+                  if (p_223089_.shouldGenerateStructures()) {
+                     for(Structure structure : map.getOrDefault(k, Collections.emptyList())) {
+                        worldgenrandom.setFeatureSeed(i, l, k);
+                        Supplier<String> supplier = () -> {
+                           return registry.getResourceKey(structure).map(Object::toString).orElseGet(structure::toString);
+                        };
+
+                        try {
+                           p_223087_.setCurrentlyGenerating(supplier);
+                           p_223089_.startsForStructure(sectionpos, structure).forEach((p_223086_) -> {
+                              p_223086_.placeInChunk(p_223087_, p_223089_, this, worldgenrandom, getWritableArea(p_223088_), chunkpos);
+                           });
+                        } catch (Exception exception) {
+                           CrashReport crashreport1 = CrashReport.forThrowable(exception, "Feature placement");
+                           crashreport1.addCategory("Feature").setDetail("Description", supplier::get);
+                           throw new ReportedException(crashreport1);
+                        }
+
+                        ++l;
+                     }
+                  }
+
+                  if (k < j) {
+                     IntSet intset = new IntArraySet();
+
+                     for(Holder<Biome> holder : set) {
+                        List<HolderSet<PlacedFeature>> list1 = this.generationSettingsGetter.apply(holder).features();
+                        if (k < list1.size()) {
+                           HolderSet<PlacedFeature> holderset = list1.get(k);
+                           FeatureSorter.StepFeatureData featuresorter$stepfeaturedata1 = list.get(k);
+                           holderset.stream().map(Holder::value).forEach((p_223174_) -> {
+                              intset.add(featuresorter$stepfeaturedata1.indexMapping().applyAsInt(p_223174_));
+                           });
+                        }
+                     }
+
+                     int j1 = intset.size();
+                     int[] aint = intset.toIntArray();
+                     Arrays.sort(aint);
+                     FeatureSorter.StepFeatureData featuresorter$stepfeaturedata = list.get(k);
+
+                     for(int k1 = 0; k1 < j1; ++k1) {
+                        int l1 = aint[k1];
+                        PlacedFeature placedfeature = featuresorter$stepfeaturedata.features().get(l1);
+                        Supplier<String> supplier1 = () -> {
+                           return registry1.getResourceKey(placedfeature).map(Object::toString).orElseGet(placedfeature::toString);
+                        };
+                        worldgenrandom.setFeatureSeed(i, l1, k);
+
+                        try {
+                           p_223087_.setCurrentlyGenerating(supplier1);
+                           placedfeature.placeWithBiomeCheck(p_223087_, this, worldgenrandom, blockpos);
+                        } catch (Exception exception1) {
+                           CrashReport crashreport2 = CrashReport.forThrowable(exception1, "Feature placement");
+                           crashreport2.addCategory("Feature").setDetail("Description", supplier1::get);
+                           throw new ReportedException(crashreport2);
+                        }
+                     }
+                  }
+               }
+
+               p_223087_.setCurrentlyGenerating((Supplier<String>)null);
+            } catch (Exception exception2) {
+               CrashReport crashreport = CrashReport.forThrowable(exception2, "Biome decoration");
+               crashreport.addCategory("Generation").setDetail("CenterX", chunkpos.x).setDetail("CenterZ", chunkpos.z).setDetail("Seed", i);
+               throw new ReportedException(crashreport);
+            }
+         }
+         
+         if (ketting$onlyAddVanillaDecoration.getAndSet(false)) return;
+      }
+
+      org.bukkit.World world = p_223087_.getMinecraftWorld().getWorld();
+      // only call when a populator is present (prevents unnecessary entity conversion)
+      if (!world.getPopulators().isEmpty()) {
+         org.bukkit.craftbukkit.v1_20_R2.generator.CraftLimitedRegion limitedRegion = new org.bukkit.craftbukkit.v1_20_R2.generator.CraftLimitedRegion(p_223087_, p_223088_.getPos());
+         int x = p_223088_.getPos().x;
+         int z = p_223088_.getPos().z;
+         for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+            WorldgenRandom seededrandom = new WorldgenRandom(new net.minecraft.world.level.levelgen.LegacyRandomSource(p_223087_.getSeed()));
+            seededrandom.setDecorationSeed(p_223087_.getSeed(), x, z);
+            populator.populate(world, new org.bukkit.craftbukkit.v1_20_R2.util.RandomSourceWrapper.RandomWrapper(seededrandom), x, z, limitedRegion);
+         }
+         limitedRegion.saveEntities();
+         limitedRegion.breakLink();
+      }
+   }
+
+   public void applyBiomeDecoration(WorldGenLevel generatoraccessseed, ChunkAccess ichunkaccess, StructureManager structuremanager, boolean vanilla) {
+      ketting$vanilla.getAndSet(vanilla);
+      applyBiomeDecoration(generatoraccessseed, ichunkaccess, structuremanager);
+      
+   }
+   // CraftBukkit end
 
    private static BoundingBox getWritableArea(ChunkAccess p_187718_) {
       ChunkPos chunkpos = p_187718_.getPos();
@@ -480,6 +_,14 @@
       Predicate<Holder<Biome>> predicate = holderset::contains;
       StructureStart structurestart = structure.generate(p_223107_, this, this.biomeSource, p_223108_, p_223109_, p_223110_, p_223112_, i, p_223111_, predicate);
       if (structurestart.isValid()) {
+         // CraftBukkit start
+         BoundingBox box = structurestart.getBoundingBox();
+         org.bukkit.event.world.AsyncStructureSpawnEvent event = new org.bukkit.event.world.AsyncStructureSpawnEvent(p_223106_.level.getMinecraftWorld().getWorld(), org.bukkit.craftbukkit.v1_20_R2.generator.structure.CraftStructure.minecraftToBukkit(structure, p_223107_), new org.bukkit.util.BoundingBox(box.minX(), box.minY(), box.minZ(), box.maxX(), box.maxY(), box.maxZ()), p_223112_.x, p_223112_.z);
+         org.bukkit.Bukkit.getPluginManager().callEvent(event);
+         if (event.isCancelled()) {
+            return true;
+         }
+         // CraftBukkit end
          p_223106_.setStartForStructure(p_223113_, structure, structurestart, p_223111_);
          return true;
       } else {
